{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(client, operation, callback) {\n  return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback);\n}\nexports.executeOperation = executeOperation;\nasync function executeOperationAsync(client, operation) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  if (client.topology == null) {\n    // Auto connect on operation\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n  const {\n    topology\n  } = client;\n  if (topology == null) {\n    throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n  }\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner;\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({\n      owner,\n      explicit: false\n    });\n  } else if (session.hasEnded) {\n    throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n  }\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  const server = await topology.selectServerAsync(selector, {\n    session\n  });\n  if (session == null) {\n    // No session also means it is not retryable, early exit\n    return operation.execute(server, undefined);\n  }\n  if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n    // non-retryable operation, early exit\n    try {\n      return await operation.execute(server, session);\n    } finally {\n      if (session?.owner != null && session.owner === owner) {\n        await session.endSession().catch(() => null);\n      }\n    }\n  }\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;\n  if (hasWriteAspect && willRetryWrite) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n  try {\n    return await operation.execute(server, session);\n  } catch (operationError) {\n    if (willRetry && operationError instanceof error_1.MongoError) {\n      return await retryOperation(operation, operationError, {\n        session,\n        topology,\n        selector\n      });\n    }\n    throw operationError;\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession().catch(() => null);\n    }\n  }\n}\nasync function retryOperation(operation, originalError, {\n  session,\n  topology,\n  selector\n}) {\n  const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n    throw new error_1.MongoServerError({\n      message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n      originalError\n    });\n  }\n  if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n    throw originalError;\n  }\n  if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n    throw originalError;\n  }\n  if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n    // If we have a cursor and the initial command fails with a network error,\n    // we can retry it on another connection. So we need to check it back in, clear the\n    // pool for the service id, and retry again.\n    session.unpin({\n      force: true,\n      forceClear: true\n    });\n  }\n  // select a new server, and attempt to retry the operation\n  const server = await topology.selectServerAsync(selector, {\n    session\n  });\n  if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n    throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n  }\n  try {\n    return await operation.execute(server, session);\n  } catch (retryError) {\n    if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n      throw originalError;\n    }\n    throw retryError;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}