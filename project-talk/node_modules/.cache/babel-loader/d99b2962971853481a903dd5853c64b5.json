{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\nconst dns = require(\"dns\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\n/** @public */\nexports.GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n});\nasync function externalCommand(connection, command) {\n  return connection.commandAsync((0, utils_1.ns)('$external.$cmd'), command, undefined);\n}\nlet krb;\nclass GSSAPI extends auth_provider_1.AuthProvider {\n  async auth(authContext) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n    if (credentials == null) {\n      throw new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n    }\n    const {\n      username\n    } = credentials;\n    const client = await makeKerberosClient(authContext);\n    const payload = await client.step('');\n    const saslStartResponse = await externalCommand(connection, saslStart(payload));\n    const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);\n    const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));\n    const finalizePayload = await finalize(client, username, saslContinueResponse.payload);\n    await externalCommand(connection, {\n      saslContinue: 1,\n      conversationId: saslContinueResponse.conversationId,\n      payload: finalizePayload\n    });\n  }\n}\nexports.GSSAPI = GSSAPI;\nasync function makeKerberosClient(authContext) {\n  const {\n    hostAddress\n  } = authContext.options;\n  const {\n    credentials\n  } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    throw new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.');\n  }\n  loadKrb();\n  if ('kModuleError' in krb) {\n    throw krb['kModuleError'];\n  }\n  const {\n    initializeClient\n  } = krb;\n  const {\n    username,\n    password\n  } = credentials;\n  const mechanismProperties = credentials.mechanismProperties;\n  const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n  const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n  const initOptions = {};\n  if (password != null) {\n    // TODO(NODE-5139): These do not match the typescript options in initializeClient\n    Object.assign(initOptions, {\n      user: username,\n      password: password\n    });\n  }\n  const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n  let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n  if ('SERVICE_REALM' in mechanismProperties) {\n    spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n  }\n  return initializeClient(spn, initOptions);\n}\nfunction saslStart(payload) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  };\n}\nfunction saslContinue(payload, conversationId) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  };\n}\nasync function negotiate(client, retries, payload) {\n  try {\n    const response = await client.step(payload);\n    return response || '';\n  } catch (error) {\n    if (retries === 0) {\n      // Retries exhausted, raise error\n      throw error;\n    }\n    // Adjust number of retries and call step again\n    return negotiate(client, retries - 1, payload);\n  }\n}\nasync function finalize(client, user, payload) {\n  // GSS Client Unwrap\n  const response = await client.unwrap(payload);\n  return client.wrap(response || '', {\n    user\n  });\n}\nasync function performGSSAPICanonicalizeHostName(host, mechanismProperties) {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n    return host;\n  }\n  // If forward and reverse or true\n  if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n    // Perform the lookup of the ip address.\n    const {\n      address\n    } = await dns.promises.lookup(host);\n    try {\n      // Perform a reverse ptr lookup on the ip address.\n      const results = await dns.promises.resolvePtr(address);\n      // If the ptr did not error but had no results, return the host.\n      return results.length > 0 ? results[0] : host;\n    } catch (error) {\n      // This can error as ptr records may not exist for all ips. In this case\n      // fallback to a cname lookup as dns.lookup() does not return the\n      // cname.\n      return resolveCname(host);\n    }\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    return resolveCname(host);\n  }\n}\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\nasync function resolveCname(host) {\n  // Attempt to resolve the host name\n  try {\n    const results = await dns.promises.resolveCname(host);\n    // Get the first resolved host id\n    return results.length > 0 ? results[0] : host;\n  } catch {\n    return host;\n  }\n}\nexports.resolveCname = resolveCname;\n/**\n * Load the Kerberos library.\n */\nfunction loadKrb() {\n  if (!krb) {\n    krb = (0, deps_1.getKerberos)();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}