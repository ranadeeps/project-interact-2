{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientEncryption = void 0;\nconst bson_1 = require(\"../bson\");\nconst deps_1 = require(\"../deps\");\nconst utils_1 = require(\"../utils\");\nconst cryptoCallbacks = require(\"./crypto_callbacks\");\nconst errors_1 = require(\"./errors\");\nconst index_1 = require(\"./providers/index\");\nconst state_machine_1 = require(\"./state_machine\");\n/**\n * @public\n * The public interface for explicit in-use encryption\n */\nclass ClientEncryption {\n  /** @internal */\n  static getMongoCrypt() {\n    const encryption = (0, deps_1.getMongoDBClientEncryption)();\n    if ('kModuleError' in encryption) {\n      throw encryption.kModuleError;\n    }\n    return encryption.MongoCrypt;\n  }\n  /**\n   * Create a new encryption instance\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     local: {\n   *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * new ClientEncryption(mongoClient, {\n   *   keyVaultNamespace: 'client.encryption',\n   *   kmsProviders: {\n   *     aws: {\n   *       accessKeyId: AWS_ACCESS_KEY,\n   *       secretAccessKey: AWS_SECRET_KEY\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  constructor(client, options) {\n    this._client = client;\n    this._proxyOptions = options.proxyOptions ?? {};\n    this._tlsOptions = options.tlsOptions ?? {};\n    this._kmsProviders = options.kmsProviders || {};\n    if (options.keyVaultNamespace == null) {\n      throw new errors_1.MongoCryptInvalidArgumentError('Missing required option `keyVaultNamespace`');\n    }\n    const mongoCryptOptions = {\n      ...options,\n      cryptoCallbacks,\n      kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders\n    };\n    this._keyVaultNamespace = options.keyVaultNamespace;\n    this._keyVaultClient = options.keyVaultClient || client;\n    const MongoCrypt = ClientEncryption.getMongoCrypt();\n    this._mongoCrypt = new MongoCrypt(mongoCryptOptions);\n  }\n  /**\n   * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create a local key\n   * const dataKeyId = await clientEncryption.createDataKey('local');\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Using async/await to create an aws key with a keyAltName\n   * const dataKeyId = await clientEncryption.createDataKey('aws', {\n   *   masterKey: {\n   *     region: 'us-east-1',\n   *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n   *   },\n   *   keyAltNames: [ 'mySpecialKey' ]\n   * });\n   * ```\n   */\n  async createDataKey(provider, options = {}) {\n    if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {\n      throw new errors_1.MongoCryptInvalidArgumentError(`Option \"keyAltNames\" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);\n    }\n    let keyAltNames = undefined;\n    if (options.keyAltNames && options.keyAltNames.length > 0) {\n      keyAltNames = options.keyAltNames.map((keyAltName, i) => {\n        if (typeof keyAltName !== 'string') {\n          throw new errors_1.MongoCryptInvalidArgumentError(`Option \"keyAltNames\" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);\n        }\n        return (0, bson_1.serialize)({\n          keyAltName\n        });\n      });\n    }\n    let keyMaterial = undefined;\n    if (options.keyMaterial) {\n      keyMaterial = (0, bson_1.serialize)({\n        keyMaterial: options.keyMaterial\n      });\n    }\n    const dataKeyBson = (0, bson_1.serialize)({\n      provider,\n      ...options.masterKey\n    });\n    const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {\n      keyAltNames,\n      keyMaterial\n    });\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const dataKey = await stateMachine.execute(this, context);\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const {\n      insertedId\n    } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {\n      writeConcern: {\n        w: 'majority'\n      }\n    });\n    return insertedId;\n  }\n  /**\n   * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.\n   *\n   * If no matches are found, then no bulk write is performed.\n   *\n   * @example\n   * ```ts\n   * // rewrapping all data data keys (using a filter that matches all documents)\n   * const filter = {};\n   *\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   * if (result.bulkWriteResult != null) {\n   *  // keys were re-wrapped, results will be available in the bulkWrite object.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // attempting to rewrap all data keys with no matches\n   * const filter = { _id: new Binary() } // assume _id matches no documents in the database\n   * const result = await clientEncryption.rewrapManyDataKey(filter);\n   *\n   * if (result.bulkWriteResult == null) {\n   *  // no keys matched, `bulkWriteResult` does not exist on the result object\n   * }\n   * ```\n   */\n  async rewrapManyDataKey(filter, options) {\n    let keyEncryptionKeyBson = undefined;\n    if (options) {\n      const keyEncryptionKey = Object.assign({\n        provider: options.provider\n      }, options.masterKey);\n      keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);\n    }\n    const filterBson = (0, bson_1.serialize)(filter);\n    const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const {\n      v: dataKeys\n    } = await stateMachine.execute(this, context);\n    if (dataKeys.length === 0) {\n      return {};\n    }\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const replacements = dataKeys.map(key => ({\n      updateOne: {\n        filter: {\n          _id: key._id\n        },\n        update: {\n          $set: {\n            masterKey: key.masterKey,\n            keyMaterial: key.keyMaterial\n          },\n          $currentDate: {\n            updateDate: true\n          }\n        }\n      }\n    }));\n    const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {\n      writeConcern: {\n        w: 'majority'\n      }\n    });\n    return {\n      bulkWriteResult: result\n    };\n  }\n  /**\n   * Deletes the key with the provided id from the keyvault, if it exists.\n   *\n   * @example\n   * ```ts\n   * // delete a key by _id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const { deletedCount } = await clientEncryption.deleteKey(id);\n   *\n   * if (deletedCount != null && deletedCount > 0) {\n   *   // successful deletion\n   * }\n   * ```\n   *\n   */\n  async deleteKey(_id) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({\n      _id\n    }, {\n      writeConcern: {\n        w: 'majority'\n      }\n    });\n  }\n  /**\n   * Finds all the keys currently stored in the keyvault.\n   *\n   * This method will not throw.\n   *\n   * @returns a FindCursor over all keys in the keyvault.\n   * @example\n   * ```ts\n   * // fetching all keys\n   * const keys = await clientEncryption.getKeys().toArray();\n   * ```\n   */\n  getKeys() {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).find({}, {\n      readConcern: {\n        level: 'majority'\n      }\n    });\n  }\n  /**\n   * Finds a key in the keyvault with the specified _id.\n   *\n   * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // getting a key by id\n   * const id = new Binary(); // id is a bson binary subtype 4 object\n   * const key = await clientEncryption.getKey(id);\n   * if (!key) {\n   *  // key is null if there was no matching key\n   * }\n   * ```\n   */\n  async getKey(_id) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n      _id\n    }, {\n      readConcern: {\n        level: 'majority'\n      }\n    });\n  }\n  /**\n   * Finds a key in the keyvault which has the specified keyAltName.\n   *\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the keyAltName.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // get a key by alt name\n   * const keyAltName = 'keyAltName';\n   * const key = await clientEncryption.getKeyByAltName(keyAltName);\n   * if (!key) {\n   *  // key is null if there is no matching key\n   * }\n   * ```\n   */\n  async getKeyByAltName(keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    return this._keyVaultClient.db(dbName).collection(collectionName).findOne({\n      keyAltNames: keyAltName\n    }, {\n      readConcern: {\n        level: 'majority'\n      }\n    });\n  }\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // adding an keyAltName to a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async addKeyAltName(_id, keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n      _id\n    }, {\n      $addToSet: {\n        keyAltNames: keyAltName\n      }\n    }, {\n      writeConcern: {\n        w: 'majority'\n      },\n      returnDocument: 'before'\n    });\n    return value;\n  }\n  /**\n   * Adds a keyAltName to a key identified by the provided _id.\n   *\n   * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).\n   *\n   * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.\n   *\n   * @param _id - The id of the document to update.\n   * @param keyAltName - a keyAltName to search for a key\n   * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents\n   * match the id.  The promise rejects with an error if an error is thrown.\n   * @example\n   * ```ts\n   * // removing a key alt name from a data key\n   * const id = new Binary();  // id is a bson binary subtype 4 object\n   * const keyAltName = 'keyAltName';\n   * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);\n   *\n   * if (!oldKey) {\n   *  // null is returned if there is no matching document with an id matching the supplied id\n   * }\n   * ```\n   */\n  async removeKeyAltName(_id, keyAltName) {\n    const {\n      db: dbName,\n      collection: collectionName\n    } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);\n    const pipeline = [{\n      $set: {\n        keyAltNames: {\n          $cond: [{\n            $eq: ['$keyAltNames', [keyAltName]]\n          }, '$$REMOVE', {\n            $filter: {\n              input: '$keyAltNames',\n              cond: {\n                $ne: ['$$this', keyAltName]\n              }\n            }\n          }]\n        }\n      }\n    }];\n    const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({\n      _id\n    }, pipeline, {\n      writeConcern: {\n        w: 'majority'\n      },\n      returnDocument: 'before'\n    });\n    return value;\n  }\n  /**\n   * A convenience method for creating an encrypted collection.\n   * This method will create data keys for any encryptedFields that do not have a `keyId` defined\n   * and then create a new collection with the full set of encryptedFields.\n   *\n   * @param db - A Node.js driver Db object with which to create the collection\n   * @param name - The name of the collection to be created\n   * @param options - Options for createDataKey and for createCollection\n   * @returns created collection and generated encryptedFields\n   * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.\n   * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.\n   */\n  async createEncryptedCollection(db, name, options) {\n    const {\n      provider,\n      masterKey,\n      createCollectionOptions: {\n        encryptedFields: {\n          ...encryptedFields\n        },\n        ...createCollectionOptions\n      }\n    } = options;\n    if (Array.isArray(encryptedFields.fields)) {\n      const createDataKeyPromises = encryptedFields.fields.map(async field => field == null || typeof field !== 'object' || field.keyId != null ? field : {\n        ...field,\n        keyId: await this.createDataKey(provider, {\n          masterKey\n        })\n      });\n      const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);\n      encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === 'fulfilled' ? resolution.value : encryptedFields.fields[index]);\n      const rejection = createDataKeyResolutions.find(result => result.status === 'rejected');\n      if (rejection != null) {\n        throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, {\n          cause: rejection.reason\n        });\n      }\n    }\n    try {\n      const collection = await db.createCollection(name, {\n        ...createCollectionOptions,\n        encryptedFields\n      });\n      return {\n        collection,\n        encryptedFields\n      };\n    } catch (cause) {\n      throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, {\n        cause\n      });\n    }\n  }\n  /**\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON\n   * @param options -\n   * @returns a Promise that either resolves with the encrypted value, or rejects with an error.\n   *\n   * @example\n   * ```ts\n   * // Encryption with async/await api\n   * async function encryptMyData(value) {\n   *   const keyId = await clientEncryption.createDataKey('local');\n   *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Encryption using a keyAltName\n   * async function encryptMyData(value) {\n   *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n   *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n   * }\n   * ```\n   */\n  async encrypt(value, options) {\n    return this._encrypt(value, false, options);\n  }\n  /**\n   * Encrypts a Match Expression or Aggregate Expression to query a range index.\n   *\n   * Only supported when queryType is \"rangePreview\" and algorithm is \"RangePreview\".\n   *\n   * @experimental The Range algorithm is experimental only. It is not intended for production use. It is subject to breaking changes.\n   *\n   * @param expression - a BSON document of one of the following forms:\n   *  1. A Match Expression of this form:\n   *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`\n   *  2. An Aggregate Expression of this form:\n   *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`\n   *\n   *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.\n   *\n   * @param options -\n   * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.\n   */\n  async encryptExpression(expression, options) {\n    return this._encrypt(expression, true, options);\n  }\n  /**\n   * Explicitly decrypt a provided encrypted value\n   *\n   * @param value - An encrypted value\n   * @returns a Promise that either resolves with the decrypted value, or rejects with an error\n   *\n   * @example\n   * ```ts\n   * // Decrypting value with async/await API\n   * async function decryptMyValue(value) {\n   *   return clientEncryption.decrypt(value);\n   * }\n   * ```\n   */\n  async decrypt(value) {\n    const valueBuffer = (0, bson_1.serialize)({\n      v: value\n    });\n    const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const {\n      v\n    } = await stateMachine.execute(this, context);\n    return v;\n  }\n  /**\n   * @internal\n   * Ask the user for KMS credentials.\n   *\n   * This returns anything that looks like the kmsProviders original input\n   * option. It can be empty, and any provider specified here will override\n   * the original ones.\n   */\n  async askForKMSCredentials() {\n    return (0, index_1.refreshKMSCredentials)(this._kmsProviders);\n  }\n  static get libmongocryptVersion() {\n    return ClientEncryption.getMongoCrypt().libmongocryptVersion;\n  }\n  /**\n   * @internal\n   * A helper that perform explicit encryption of values and expressions.\n   * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n   * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n   *\n   * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON\n   * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression\n   * @param options - options to pass to encrypt\n   * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return\n   *          value will be a bson document.  When false, the value will be a BSON Binary.\n   *\n   */\n  async _encrypt(value, expressionMode, options) {\n    const {\n      algorithm,\n      keyId,\n      keyAltName,\n      contentionFactor,\n      queryType,\n      rangeOptions\n    } = options;\n    const contextOptions = {\n      expressionMode,\n      algorithm\n    };\n    if (keyId) {\n      contextOptions.keyId = keyId.buffer;\n    }\n    if (keyAltName) {\n      if (keyId) {\n        throw new errors_1.MongoCryptInvalidArgumentError(`\"options\" cannot contain both \"keyId\" and \"keyAltName\"`);\n      }\n      if (typeof keyAltName !== 'string') {\n        throw new errors_1.MongoCryptInvalidArgumentError(`\"options.keyAltName\" must be of type string, but was of type ${typeof keyAltName}`);\n      }\n      contextOptions.keyAltName = (0, bson_1.serialize)({\n        keyAltName\n      });\n    }\n    if (typeof contentionFactor === 'number' || typeof contentionFactor === 'bigint') {\n      contextOptions.contentionFactor = contentionFactor;\n    }\n    if (typeof queryType === 'string') {\n      contextOptions.queryType = queryType;\n    }\n    if (typeof rangeOptions === 'object') {\n      contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);\n    }\n    const valueBuffer = (0, bson_1.serialize)({\n      v: value\n    });\n    const stateMachine = new state_machine_1.StateMachine({\n      proxyOptions: this._proxyOptions,\n      tlsOptions: this._tlsOptions\n    });\n    const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n    const result = await stateMachine.execute(this, context);\n    return result.v;\n  }\n}\nexports.ClientEncryption = ClientEncryption;","map":null,"metadata":{},"sourceType":"script"}